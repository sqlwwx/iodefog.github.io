<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="iodefog"><title>iOS 贝赛尔曲线(BezierPath)常用方法研究 · iodefog</title><meta name="description" content="UIBezierPath这个类在UIKit中， 是Core Graphics框架关于path的一个封装，使用此类可以定义简单的形状，比如我们常用到，矩形，圆形，椭圆，弧，或者不规则的多边形



目录  贝塞尔曲线可以做到哪些？  贝塞尔曲线是怎么画出来的？  常用设置介绍说明  画图形  Bezi"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/./images/logo.png" style="width:127px;"><h3 title=""><a href="/">iodefog</a></h3><div class="description"><p>记录人生道路景色的，点点滴滴。</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li><li><a href="/links">链接</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>iOS 贝赛尔曲线(BezierPath)常用方法研究</a></h3></div><div class="post-content"><p>UIBezierPath这个类在UIKit中， 是Core Graphics框架关于path的一个封装，使用此类可以定义简单的形状，比如我们常用到，矩形，圆形，椭圆，弧，或者不规则的多边形</p>
<hr>
<a id="more"></a>
<ul>
<li><a href="#">目录</a><br>  <a href="#贝塞尔曲线可以做到哪些？">贝塞尔曲线可以做到哪些？</a><br>  <a href="#贝塞尔曲线是怎么画出来的？">贝塞尔曲线是怎么画出来的？</a><br>  <a href="#常用设置介绍说明">常用设置介绍说明</a><br>  <a href="#画图形">画图形</a><br>  <a href="#BezierPath动画">BezierPath动画</a><br>  <a href="#了解一下底层的CoreGraphics">了解一下底层的CoreGraphics</a><br>  <a href="#通过shapeLayer画线">通过shapeLayer画线</a></li>
</ul>
<h1 id="贝塞尔曲线可以做到哪些？"><a href="#贝塞尔曲线可以做到哪些？" class="headerlink" title="贝塞尔曲线可以做到哪些？"></a>贝塞尔曲线可以做到哪些？</h1><p>1.画图形<br>2.做动画</p>
<h1 id="贝塞尔曲线是怎么画出来的？"><a href="#贝塞尔曲线是怎么画出来的？" class="headerlink" title="贝塞尔曲线是怎么画出来的？"></a>贝塞尔曲线是怎么画出来的？</h1><p>首先，我们在平面内选3个不同线的点并且依次用线段连接。如下所示..</p>
<p><img src="/img/56030-48977fcfcd8cd57e.png" alt="image"></p>
<p>接着，我们在AB和BC线段上找出点D和点E，使得AD/AB = BE/BC。</p>
<p><img src="/img/56030-5d3e252f34e657c9.jpg" alt="image"></p>
<p>再接着，连接DE，并在DE上找出一点F，使得DF/DE = AD/AB = BE/BC。</p>
<p><img src="/img/56030-5175f6c03d4990b2.jpg" alt="image"></p>
<p>然后，根据我们高中所学的极限的知识，让选取的点D在第一条线段上从起点A，移动到终点B，找出所有点F，并将它们连起来。最后你会发现，你得到了一条非常光滑的曲线，这条就是传说中的，贝塞尔曲线。</p>
<p>这是二阶贝塞尔曲线。</p>
<p><img src="/img/56030-bb6b8c6a46f12135.gif" alt="image"></p>
<p>下面是三阶四阶和五阶。</p>
<p><img src="/img/56030-f3e69b487f4e37c8.gif" alt="image"></p>
<p><img src="/img/56030-2d2fb8989e10f177.gif" alt="image"></p>
<p><img src="/img/56030-390b7b874ddd5d3d.gif" alt="image"></p>
<p>最后看一下一阶</p>
<p><img src="/img/56030-b65e3dd8196f4da5.gif" alt="image"></p>
<p>所以贝塞尔曲线的厉害之处就在这里，从1-n阶的连续函数，他都可以计算得到一条光滑曲线。</p>
<p>提供一个比较牛x的在线查看贝塞尔曲线网址</p>
<p>Animated Bézier Curves<br><a href="https://www.jasondavies.com/animated-bezier/" target="_blank" rel="noopener">https://www.jasondavies.com/animated-bezier/</a></p>
<h1 id="常用设置介绍说明"><a href="#常用设置介绍说明" class="headerlink" title="常用设置介绍说明"></a>常用设置介绍说明</h1><p>1、[color set];设置线条颜色，也就是相当于画笔颜色</p>
<p>2、path.lineWidth = 5.0;这个很好理解了，就是划线的宽度</p>
<p>3、path.lineCapStyle这个线段起点是终点的样式，这个样式有三种：</p>
<ul>
<li>1、kCGLineCapButt该属性值指定不绘制端点， 线条结尾处直接结束。这是默认值。</li>
<li>2、kCGLineCapRound 该属性值指定绘制圆形端点， 线条结尾处绘制一个直径为线条宽度的半圆。</li>
<li>3、kCGLineCapSquare 该属性值指定绘制方形端点。 线条结尾处绘制半个边长为线条宽度的正方形。需要说明的是，这种形状的端点与“butt”形状的端点十分相似，只是采用这种形式的端点的线条略长一点而已</li>
</ul>
<p>4、path.lineJoinStyle这个属性是用来设置两条线连结点的样式，同样它也有三种样式供我们选择</p>
<ul>
<li>1、kCGLineJoinMiter 斜接</li>
<li>2、kCGLineJoinRound 圆滑衔接</li>
<li>3、kCGLineJoinBevel 斜角连接</li>
</ul>
<p>5、[path stroke];用 stroke 得到的是不被填充的 view ，[path fill]; 用 fill 得到的内部被填充的 view，这点在下面的代码还有绘制得到的图片中有，可以体会一下这两者的不同。</p>
<h1 id="画图形"><a href="#画图形" class="headerlink" title="画图形"></a>画图形</h1><h3 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h3><p><img src="/img/WX20171212-152501.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 画线</span><br><span class="line">- (void)createTest0&#123;</span><br><span class="line">    UIColor *color = [UIColor redColor];</span><br><span class="line">    [color set]; //设置线条颜色</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">    [path moveToPoint:CGPointMake(10, 100)];</span><br><span class="line">    [path addLineToPoint:CGPointMake(200, 250)];</span><br><span class="line">    </span><br><span class="line">    [path addLineToPoint:CGPointMake(100, 350)];</span><br><span class="line">    path.lineWidth = 4;</span><br><span class="line">    path.lineCapStyle = kCGLineCapRound ;//kCGLineCapRound; //线条拐角</span><br><span class="line">    path.lineJoinStyle = kCGLineCapRound;  //终点处理</span><br><span class="line">    </span><br><span class="line">    [path stroke];</span><br><span class="line">//    [path fill];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五边形"><a href="#五边形" class="headerlink" title="五边形"></a>五边形</h3><p><img src="/img/WX20171212-152805.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 五边形</span><br><span class="line">- (void)createTest1&#123;</span><br><span class="line">    UIColor *color = [UIColor redColor];</span><br><span class="line">    [color set]; //设置线条颜色</span><br><span class="line"></span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">    path.lineWidth = 5;</span><br><span class="line">    </span><br><span class="line">    path.lineJoinStyle = kCGLineJoinRound;</span><br><span class="line">    path.lineCapStyle = kCGLineCapRound;</span><br><span class="line">    </span><br><span class="line">    [path moveToPoint:CGPointMake(200, 50)];</span><br><span class="line">    </span><br><span class="line">    [path addLineToPoint:CGPointMake(300, 100)];</span><br><span class="line">    [path addLineToPoint:CGPointMake(260, 200)];</span><br><span class="line">    [path addLineToPoint:CGPointMake(100, 200)];</span><br><span class="line">    [path addLineToPoint:CGPointMake(100, 70)];</span><br><span class="line">    </span><br><span class="line">    [path closePath];</span><br><span class="line">    </span><br><span class="line">    [path stroke];</span><br><span class="line">//    [path fill];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正方形或者矩形"><a href="#正方形或者矩形" class="headerlink" title="正方形或者矩形"></a>正方形或者矩形</h3><p><img src="/img/WX20171212-152956.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 正方形或者矩形</span><br><span class="line">- (void)createTest2&#123;</span><br><span class="line">    UIColor *color = [UIColor redColor];</span><br><span class="line">    [color set]; //设置线条颜色</span><br><span class="line"></span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(20, 20, 200, 200)];</span><br><span class="line">    path.lineWidth = 5;</span><br><span class="line">    path.lineJoinStyle = kCGLineJoinRound;</span><br><span class="line">    path.lineCapStyle = kCGLineCapRound;</span><br><span class="line">    </span><br><span class="line">    [path stroke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="椭圆或者圆"><a href="#椭圆或者圆" class="headerlink" title="椭圆或者圆"></a>椭圆或者圆</h3><p><img src="/img/WX20171212-153438.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 椭圆或者圆</span><br><span class="line">- (void)createTest3&#123;</span><br><span class="line">    UIColor *color = [UIColor redColor];</span><br><span class="line">    [color set]; //设置线条颜色</span><br><span class="line"></span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(20, 40, 300, 200)];</span><br><span class="line">    path.lineWidth = 5;</span><br><span class="line">    path.lineJoinStyle = kCGLineJoinRound;</span><br><span class="line">    path.lineCapStyle = kCGLineCapRound;</span><br><span class="line">    [path stroke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩形四角圆角"><a href="#矩形四角圆角" class="headerlink" title="矩形四角圆角"></a>矩形四角圆角</h3><p><img src="/img/WX20171212-153537.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 矩形四角圆角</span><br><span class="line">- (void)createTest4&#123;</span><br><span class="line">    UIColor *color = [UIColor redColor];</span><br><span class="line">    [color set];</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, 200, 200) cornerRadius:50];</span><br><span class="line">    [path fill];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四个角里右上和左下圆角"><a href="#四个角里右上和左下圆角" class="headerlink" title="四个角里右上和左下圆角"></a>四个角里右上和左下圆角</h3><p><img src="/img/WX20171212-153737.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 四个角里右上和左下圆角</span><br><span class="line">- (void)createTest5&#123;</span><br><span class="line">    UIColor *color = [UIColor redColor];</span><br><span class="line">    [color set];</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, 200, 200) byRoundingCorners:UIRectCornerTopRight|UIRectCornerBottomLeft cornerRadii:CGSizeMake(50, 50)];</span><br><span class="line">    </span><br><span class="line">    [path fill];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺时针或者逆时针画线"><a href="#顺时针或者逆时针画线" class="headerlink" title="顺时针或者逆时针画线"></a>顺时针或者逆时针画线</h3><p><img src="/img/WX20171212-153917.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 顺时针或者逆时针画线</span><br><span class="line">- (void)createTest6&#123;</span><br><span class="line">    UIColor *color = [UIColor redColor];</span><br><span class="line">    [color set];</span><br><span class="line"></span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(200, 200) radius:50 startAngle:M_PI_2 endAngle:M_PI*2 clockwise:YES];</span><br><span class="line">    path.lineWidth = 10;</span><br><span class="line"></span><br><span class="line">    [path stroke];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绘制二次贝塞尔曲线"><a href="#绘制二次贝塞尔曲线" class="headerlink" title="绘制二次贝塞尔曲线"></a>绘制二次贝塞尔曲线</h3><p><img src="/img/WX20171212-154002.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 绘制二次贝塞尔曲线</span><br><span class="line">- (void)createTest7&#123;</span><br><span class="line">    UIColor *color = [UIColor redColor];</span><br><span class="line">    [color set];</span><br><span class="line"></span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">    </span><br><span class="line">    path.lineWidth = 5;</span><br><span class="line">    </span><br><span class="line">    [path moveToPoint:CGPointMake(20, 200)];</span><br><span class="line">    </span><br><span class="line">    [path addQuadCurveToPoint:CGPointMake(20+40*1, 200) controlPoint:CGPointMake(40*1, 0)];</span><br><span class="line">    </span><br><span class="line">    [path addQuadCurveToPoint:CGPointMake(20+40*2, 200) controlPoint:CGPointMake(40*2, 0)];</span><br><span class="line"></span><br><span class="line">    [path addQuadCurveToPoint:CGPointMake(20+40*3, 200) controlPoint:CGPointMake(40*3, 0)];</span><br><span class="line"></span><br><span class="line">    [path addQuadCurveToPoint:CGPointMake(20+40*4, 200) controlPoint:CGPointMake(40*4, 0)];</span><br><span class="line"></span><br><span class="line">//    [path addQuadCurveToPoint:CGPointMake(200, 200) controlPoint:CGPointMake(180*3/2., 180*1/5.)];</span><br><span class="line">    </span><br><span class="line">//    [path stroke];</span><br><span class="line">    [path fill];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绘制三次贝塞尔曲线"><a href="#绘制三次贝塞尔曲线" class="headerlink" title="绘制三次贝塞尔曲线"></a>绘制三次贝塞尔曲线</h3><p><img src="/img/WX20171212-154104.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//绘制三次贝塞尔曲线</span><br><span class="line">- (void)createTest8&#123;</span><br><span class="line">    UIColor *color = [UIColor redColor];</span><br><span class="line">    [color set];</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">    </span><br><span class="line">    path.lineWidth = 5;</span><br><span class="line"></span><br><span class="line">    [path moveToPoint:CGPointMake(20, 200)];</span><br><span class="line">    [path addCurveToPoint:CGPointMake(130, 200) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(75, 400)];</span><br><span class="line">    [path addCurveToPoint:CGPointMake(260, 200) controlPoint1:CGPointMake(195, 0) controlPoint2:CGPointMake(195, 400)];</span><br><span class="line"></span><br><span class="line">    [path fill];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="BezierPath动画"><a href="#BezierPath动画" class="headerlink" title="BezierPath动画"></a>BezierPath动画</h1><p><img src="/img/bezierpathAnimation.gif" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> /*</span><br><span class="line">     这个属性用以指定时间函数，类似于运动的加速度</span><br><span class="line">     kCAMediaTimingFunctionLinear//线性</span><br><span class="line">     kCAMediaTimingFunctionEaseIn//淡入</span><br><span class="line">     kCAMediaTimingFunctionEaseOut//淡出</span><br><span class="line">     kCAMediaTimingFunctionEaseInEaseOut//淡入淡出</span><br><span class="line">     kCAMediaTimingFunctionDefault//默认</span><br><span class="line"></span><br><span class="line">    kCAFillModeForwards</span><br><span class="line">    fillMode的作用就是决定当前对象过了非active时间段的行为. 比如动画开始之前,动画结束之后。如果是一个动画CAAnimation,则需要将其removedOnCompletion设置为NO,要不然fillMode不起作用.</span><br><span class="line">     </span><br><span class="line">     下面来讲各个fillMode的意义</span><br><span class="line">     kCAFillModeRemoved 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态</span><br><span class="line">     kCAFillModeForwards 当动画结束后,layer会一直保持着动画最后的状态</span><br><span class="line">     kCAFillModeBackwards 这个和kCAFillModeForwards是相对的,就是在动画开始前,你只要将动画加入了一个layer,layer便立即进入动画的初始状态并等待动画开始.你可以这样设定测试代码,将一个动画加入一个layer的时候延迟5秒执行.然后就会发现在动画没有开始的时候,只要动画被加入了layer,layer便处于动画初始状态</span><br><span class="line">     kCAFillModeBoth 理解了上面两个,这个就很好理解了,这个其实就是上面两个的合成.动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态.</span><br><span class="line"></span><br><span class="line">     kCAAnimationPaced</span><br><span class="line">     在关键帧动画中还有一个非常重要的参数,那便是calculationMode,计算模式.该属性决定了物体在每个子路径下是跳着走还是匀速走，跟timeFunctions属性有点类似</span><br><span class="line">     其主要针对的是每一帧的内容为一个座标点的情况,也就是对anchorPoint 和 position 进行的动画.当在平面座标系中有多个离散的点的时候,可以是离散的,也可以直线相连后进行插值计算,也可以使用圆滑的曲线将他们相连后进行插值计算. calculationMode目前提供如下几种模式</span><br><span class="line">     </span><br><span class="line">     kCAAnimationLinear calculationMode的默认值,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;</span><br><span class="line">     kCAAnimationDiscrete 离散的,就是不进行插值计算,所有关键帧直接逐个进行显示;</span><br><span class="line">     kCAAnimationPaced 使得动画均匀进行,而不是按keyTimes设置的或者按关键帧平分时间,此时keyTimes和timingFunctions无效;</span><br><span class="line">     kCAAnimationCubic 对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,这里的数学原理是Kochanek–Bartels spline,这里的主要目的是使得运行的轨迹变得圆滑;</span><br><span class="line">     kCAAnimationCubicPaced 看这个名字就知道和kCAAnimationCubic有一定联系,其实就是在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时keyTimes以及timingFunctions也是无效的.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 贝塞尔曲线动画</span><br><span class="line">- (void)createTest12&#123;</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">    [path moveToPoint:CGPointMake(100, 200)];</span><br><span class="line">    [path addCurveToPoint:CGPointMake(400, 200) controlPoint1:CGPointMake(200, 0) controlPoint2:CGPointMake(300, 400)];</span><br><span class="line">    </span><br><span class="line">    CAKeyframeAnimation *keyFA = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    keyFA.duration = 8;</span><br><span class="line">    keyFA.repeatCount = 10;</span><br><span class="line">    keyFA.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</span><br><span class="line">    keyFA.path = path.CGPath;</span><br><span class="line">    keyFA.calculationMode = kCAAnimationPaced;</span><br><span class="line">    //旋转的模式,auto就是沿着切线方向动，autoReverse就是转180度沿着切线动</span><br><span class="line">    keyFA.rotationMode = kCAAnimationRotateAuto;</span><br><span class="line">    //结束后是否移除动画</span><br><span class="line">    keyFA.removedOnCompletion = NO;</span><br><span class="line">    </span><br><span class="line">    //添加动画</span><br><span class="line">    [self.redView.layer addAnimation:keyFA forKey:@&quot;&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)drawRect:(CGRect)rect&#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    </span><br><span class="line">    UIColor *color = [UIColor redColor];</span><br><span class="line">    [color set];</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">    [path moveToPoint:CGPointMake(100, 200)];</span><br><span class="line">    path.lineWidth = 3;</span><br><span class="line">    path.lineJoinStyle = kCGLineJoinRound;</span><br><span class="line">    path.lineCapStyle = kCGLineCapRound;</span><br><span class="line">    [path addCurveToPoint:CGPointMake(400, 200) controlPoint1:CGPointMake(200, 0) controlPoint2:CGPointMake(300, 400)];</span><br><span class="line">    [path stroke];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="了解一下底层的CoreGraphics"><a href="#了解一下底层的CoreGraphics" class="headerlink" title="了解一下底层的CoreGraphics"></a>了解一下底层的CoreGraphics</h1><p>简单易懂的介绍博客</p>
<p><a href="http://www.mamicode.com/info-detail-841887.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-841887.html</a></p>
<p>下面介绍了怎样给BezierPath赋值CGPath，我看有点用，直接把代码拿来了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(void)drawRect:(CGRect)rect  </span><br><span class="line">&#123;  </span><br><span class="line">    // Create the path data  </span><br><span class="line">    //创建路径时间  </span><br><span class="line">    CGMutablePathRef cgPath = CGPathCreateMutable();  </span><br><span class="line">    </span><br><span class="line">    //cgPath的画图接口  </span><br><span class="line">    //给一个cgPath里面添加了多个样式，圆和椭圆会发生关联  </span><br><span class="line">      </span><br><span class="line">    //两个椭圆互不影响  </span><br><span class="line">    CGPathAddEllipseInRect(cgPath, NULL, CGRectMake(100, 100, 50, 100));  </span><br><span class="line">      </span><br><span class="line">    CGPathAddEllipseInRect(cgPath, NULL, CGRectMake(250, 250, 100, 50));  </span><br><span class="line">      </span><br><span class="line">    //矩形  </span><br><span class="line">    CGPathAddRect(cgPath, NULL, CGRectMake(200, 500, 30, 100));        </span><br><span class="line">//    圆形  </span><br><span class="line">//    CGPathAddArc(cgPath, NULL, 120, 400, 100, 0, M_PI*2, YES);  </span><br><span class="line">      </span><br><span class="line">    //下面两句要搭配，先有起点  </span><br><span class="line">    CGPathMoveToPoint(cgPath, NULL, 200, 300);  </span><br><span class="line">    //加一段弧  </span><br><span class="line">    CGPathAddArcToPoint(cgPath, NULL, 320, 250, DEGREES_TO_RADIANS(150), M_PI*2, 50);  </span><br><span class="line">  </span><br><span class="line">              </span><br><span class="line">    //把CGPath赋给贝塞尔曲线  </span><br><span class="line">    UIBezierPath* aPath = [UIBezierPath bezierPath];  </span><br><span class="line">      </span><br><span class="line">    aPath.CGPath = cgPath;  </span><br><span class="line">      </span><br><span class="line">    aPath.usesEvenOddFillRule = YES;  </span><br><span class="line">      </span><br><span class="line">   //并不在ARC的管理范围之内。所以需要手动释放对象，释放cgPath  </span><br><span class="line">    CGPathRelease(cgPath);  </span><br><span class="line">      </span><br><span class="line">    //划线  </span><br><span class="line">    [[UIColor redColor]setStroke];  </span><br><span class="line">    [aPath setLineWidth:5];  </span><br><span class="line">    [aPath stroke];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="通过shapeLayer画线"><a href="#通过shapeLayer画线" class="headerlink" title="通过shapeLayer画线"></a>通过shapeLayer画线</h1><p>这样就不用去UIView的drawRect方法里面画图了,用法“给CAShapeLayer赋值 CGPath”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//ShapeLayer  </span><br><span class="line">-(void)createTest10 </span><br><span class="line">&#123;  </span><br><span class="line">    //贝塞尔画圆  </span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(100, 100) radius:100 startAngle:0 endAngle:M_PI clockwise:NO];  </span><br><span class="line">      </span><br><span class="line">    //初始化shapeLayer  </span><br><span class="line">    self.myShapeLayer = [CAShapeLayer layer];  </span><br><span class="line">    _myShapeLayer.frame = _redView.bounds;  </span><br><span class="line">  </span><br><span class="line">    _myShapeLayer.strokeColor = [UIColor greenColor].CGColor;//边沿线色   </span><br><span class="line">    _myShapeLayer.fillColor = [UIColor grayColor].CGColor;//填充色  </span><br><span class="line">      </span><br><span class="line">    _myShapeLayer.lineJoin = kCALineJoinMiter;//线拐点的类型  </span><br><span class="line">    _myShapeLayer.lineCap = kCALineCapSquare;//线终点  </span><br><span class="line">            </span><br><span class="line">    //从贝塞尔曲线获得形状  </span><br><span class="line">    _myShapeLayer.path = path.CGPath;  </span><br><span class="line">      </span><br><span class="line">    //线条宽度  </span><br><span class="line">    _myShapeLayer.lineWidth = 10;  </span><br><span class="line">      </span><br><span class="line">    //起始和终止  </span><br><span class="line">    _myShapeLayer.strokeStart = 0.0;  </span><br><span class="line">    _myShapeLayer.strokeEnd = 1.0;  </span><br><span class="line">            </span><br><span class="line">    //将layer添加进图层  </span><br><span class="line">    [self.redView.layer addSublayer:_myShapeLayer];          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是我调试时的demo：<a href="https://github.com/iOdeFog/BezierPathDemo" target="_blank" rel="noopener">https://github.com/iOdeFog/BezierPathDemo</a></p>
<p>参考:<br><a href="http://cdn2.jianshu.io/p/c883fbf52681" target="_blank" rel="noopener">http://cdn2.jianshu.io/p/c883fbf52681</a><br><a href="http://www.jianshu.com/p/5dbdd1ee47aa" target="_blank" rel="noopener">http://www.jianshu.com/p/5dbdd1ee47aa</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-11-06</span><i class="fa fa-tag"></i><a href="/categories/object-c/" title="object-c" class="tag">object-c </a><a href="/tags/iOS-贝塞尔曲线-BezierPath/" title="iOS, 贝塞尔曲线, BezierPath" class="tag">iOS, 贝塞尔曲线, BezierPath </a></div></div></div></div><div class="pagination"><ul class="clearfix"></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>